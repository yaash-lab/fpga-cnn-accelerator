import torch
import numpy as np
from torchvision import transforms
from PIL import Image
import os
from cnn_model import TrafficSignCNN

def export_test_data():
    # Load trained model
    model = TrafficSignCNN(num_classes=43)
    model.load_state_dict(torch.load('models/traffic_sign_cnn.pth'))
    model.eval()
    
    # Transform
    transform = transforms.Compose([
        transforms.Resize((32, 32)),
        transforms.ToTensor(),
        transforms.Normalize(mean=[0.485, 0.456, 0.406], 
                           std=[0.229, 0.224, 0.225])
    ])
    
    # Get test images - multiple per class
    train_dir = 'data/raw/GTSRB/Final_Training/Images'
    test_images = []
    test_labels = []
    
    # Collect images from all 43 classes (3 per class = 129 total)
     class_folders = sorted(os.listdir(train_dir))[:43]
    
    for class_folder in class_folders:
        class_path = os.path.join(train_dir, class_folder)
        if not os.path.isdir(class_path):
            continue
        
        # Get 3 images from this class
        count = 0
        for img_file in os.listdir(class_path):
            if img_file.endswith('.ppm') and count < 3:
                img_path = os.path.join(class_path, img_file)
                img = Image.open(img_path).convert('RGB')
                img_tensor = transform(img).unsqueeze(0)
                
                test_images.append(img_tensor)
                test_labels.append(int(class_folder))
                count += 1  # <-- INCREMENT HERE
            
            if count >= 3:              
                break
    
    # Stack images
    test_batch = torch.cat(test_images, dim=0)
    
    # Get golden outputs
    with torch.no_grad():
        outputs = model(test_batch)
        predictions = torch.argmax(outputs, dim=1)
    
    # Save test data
    os.makedirs('data/processed', exist_ok=True)
    
    # Save as numpy arrays
    np.save('data/processed/test_images.npy', test_batch.numpy())
    np.save('data/processed/test_labels.npy', np.array(test_labels))
    np.save('data/processed/golden_predictions.npy', predictions.numpy())
    np.save('data/processed/golden_outputs.npy', outputs.numpy())
    
    print(f"Exported {len(test_images)} test images")
    print(f"Test labels: {test_labels}")
    print(f"Predictions: {predictions.numpy().tolist()}")
    print(f"Accuracy: {(predictions.numpy() == np.array(test_labels)).sum()}/{len(test_labels)}")
    
    # Also export model weights for reference
    print("\nExporting model weights...")
    weights = {}
    for name, param in model.named_parameters():
        weights[name] = param.detach().numpy()
        print(f"  {name}: {param.shape}")
    
    np.savez('models/model_weights.npz', **weights)
    print("\nWeights saved to models/model_weights.npz")
    print("Test data saved to data/processed/")

if __name__ == "__main__":
    export_test_data()
